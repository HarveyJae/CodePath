# 冒泡排序：
## 冒泡排序的基本思想：

- 从头开始，比较相邻的元素。如果第一个比第二个大，就交换他们两个。
- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。
   - 这步做完后，**最后的元素会是最大的数**。
- 针对所有的元素重复以上的步骤，除了最后一个(最后一个不需要比较，一定是最小的)。

![bubbleSort.gif](https://cdn.nlark.com/yuque/0/2024/gif/35940756/1720847055256-18e813a3-a99a-40db-b6e6-0cf3fa0f9a70.gif#averageHue=%23d2e2e8&clientId=ud8293749-df66-4&from=paste&height=129&id=u8e04d22a&originHeight=257&originWidth=826&originalType=binary&ratio=2&rotation=0&showTitle=false&size=351100&status=done&style=none&taskId=u27052c7c-8b08-4356-a895-d4f4fd0ce9d&title=&width=413)

- **冒泡排序**有一种**优化策略**，就是立一个`flag`，当在一趟列表遍历中没有发生元素交换，则证明排序完成，此时`break`掉即可。
   - 这种方式对于冒泡排序的性能提升微乎其微。
- **冒泡排序的时间复杂度分析**：
   - **最差情况**：数组**逆序**，此时的时间复杂度是**O(n****2****)**
   - **最优情况**：数组**顺序**，此时的时间复杂度是**O(n)**
## 冒泡排序的代码实现：
```java
for (int i = 0; i < a.length; i++) {
    //最外层循环表示对每个元素进行排序(每次都找出一个最大的元素放到最后)
    for (int j = 0; j < a.length - i - 1; j++) {
        //表示对当前待排序列进行迭代，-1目的是不让数组越界
        if (a[j] > a[j+1]) {
            temp = a[j];
            a[j] = a[j + 1];
            a[j + 1] = temp;
        }
    }
}
```
# 选择排序：
## 选择排序的基本思想：

- 

## 选择排序的代码实现：

- 

# 插入排序*：
## 插入排序的基本思想：

- 

## 插入排序的代码实现：

- 

# 快速排序*：
## 快速排序的基本思想：

- 

## 快速排序的代码实现：

- 

# 归并排序*：
## 归并排序的基本思想：

- 

## 归并排序的代码实现：

- 

# 堆排序：
## 堆排序的基本思想：

- 

## 堆排序的代码实现：

- 

# 计数排序：
## 计数排序的基本思想：

- 

# 基数排序：
## 基数排序的基本思想：

- 


