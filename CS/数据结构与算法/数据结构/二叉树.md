# 二叉树的概念：
- **二叉树binary tree**，是一种**非线性**数据结构，代表“祖先”与“后代”之间的派生关系。
- 二叉树的基本单元是**节点Node**，每个节点包含值、左子节点的引用、右子节点的引用。
```java
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
}
```
![image.png](https://cdn.nlark.com/yuque/0/2024/png/35940756/1721208027486-41b56d9e-757f-4b2e-932c-1a5aff41955a.png#averageHue=%23fdfbfa&clientId=ud93b83a1-9096-4&from=paste&height=374&id=u5e486f6c&originHeight=747&originWidth=1333&originalType=binary&ratio=2&rotation=0&showTitle=false&size=145612&status=done&style=none&taskId=u8e632471-72c7-431c-9b00-d3b5305ed99&title=&width=666.5)
## 二叉树的常用术语：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/35940756/1721208204070-2302ec27-042f-4293-8bcb-a39a453ec9e3.png#averageHue=%23fcfcfc&clientId=ud93b83a1-9096-4&from=paste&height=367&id=ue71e988a&originHeight=733&originWidth=1327&originalType=binary&ratio=2&rotation=0&showTitle=false&size=142267&status=done&style=none&taskId=u942276ee-9bc3-4eeb-985d-046cfe301f7&title=&width=663.5)

- **根节点root node**：位于二叉树顶层的节点，没有父节点。
- **叶节点leaf node**：没有子节点的节点。
- **边edge**：连接两个节点的线段，即引用。
- **节点所在的层level**：从顶到底递增，根节点所在的层为1。
- **节点的度degree**：节点的子节点数量，可以是0、1或2。
- **节点的高度height**：从该节点到距离该节点最远的叶节点所经过的边数。
- **节点的深度depth**：从根节点到该节点所经过的边数。
- **二叉树的高度height**：从根节点到最远叶节点所经过的边数。
## 常见二叉树类型：
### 完美二叉树：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/35940756/1721209440591-5c65bc85-8d8c-494c-8be3-7c31878409bf.png#averageHue=%23fcfcfc&clientId=ud93b83a1-9096-4&from=paste&height=345&id=ubedb6240&originHeight=689&originWidth=1343&originalType=binary&ratio=2&rotation=0&showTitle=false&size=112522&status=done&style=none&taskId=u1b441cea-65f3-40ed-9ca8-8ff229aebfc&title=&width=671.5)

- **完美二叉树perfect binary tree**，也叫**满二叉树**，叶节点的度为0，其余所有节点的度都为2，根节点左右子树的高度相同。
- 当前层的**深度**为`depth`，则该层的节点数：`2depth`。
- 设树的**层数**为`h`，则节点总数为`2h-1`。
   - **树的高度 = 树的层数 - 1**。
### 完全二叉树：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/35940756/1721209546589-b8db5648-273b-48d7-b83d-6964c8353a75.png#averageHue=%23fbfbfb&clientId=ud93b83a1-9096-4&from=paste&height=343&id=u6b55aebf&originHeight=685&originWidth=1319&originalType=binary&ratio=2&rotation=0&showTitle=false&size=99010&status=done&style=none&taskId=ufab1e6e3-e1f8-4126-b10a-5948e839b45&title=&width=659.5)

- **完全二叉树complete binary tree**，最底层上面的部分是完美二叉树，**最底层的节点未被填满，并且靠左填充**。
### 完满二叉树：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/35940756/1721210019034-81e1fa74-c8a6-4b35-8d98-4ed4779a1506.png#averageHue=%23fdfdfd&clientId=ud93b83a1-9096-4&from=paste&height=353&id=ub5bea2bf&originHeight=705&originWidth=1349&originalType=binary&ratio=2&rotation=0&showTitle=false&size=67377&status=done&style=none&taskId=u7d496a2a-4980-4a2f-a3a5-47fcc3c6064&title=&width=674.5)

- **完满二叉树full binary tree**，叶节点的度为0，其他节点的度为2。
### 平衡二叉树：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/35940756/1721210380083-cc9d40c6-1d10-4365-ba36-3f34806f4351.png#averageHue=%23fbfbfb&clientId=ud93b83a1-9096-4&from=paste&height=335&id=u67f9efd8&originHeight=669&originWidth=1335&originalType=binary&ratio=2&rotation=0&showTitle=false&size=91935&status=done&style=none&taskId=u3e09d9ae-b425-4027-a21b-8d223071c4f&title=&width=667.5)

- **平衡二叉树balanced binary tree**，任意节点的左子树和右子树的高度差的绝对值不超过1。
## 二叉树的最佳结构与最差结构：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/35940756/1721210748643-39741ca3-6fbf-4c90-b6cc-b82aac4659d1.png#averageHue=%23fdfdfd&clientId=ud93b83a1-9096-4&from=paste&height=352&id=u88dda8a9&originHeight=703&originWidth=1317&originalType=binary&ratio=2&rotation=0&showTitle=false&size=115999&status=done&style=none&taskId=u9656bdfd-61b8-4649-9c9e-de695de7b6f&title=&width=658.5)

- 完美二叉树是理想情况，可以充分发挥二叉树的“分治”优势。
- 链表是二叉树的极端，各项操作都变为线性操作。
# 遍历二叉树：
## 层序遍历：
[二叉树的层序遍历](https://www.yuque.com/yunyehewang/uk5chv/qpli929cc8ph1hx3)
## 深度优先遍历：
[二叉树的深度优先遍历](https://www.yuque.com/yunyehewang/uk5chv/ay9nkibb6ydrlnug)
# 二叉树的数组表示：

- 在**链表**表示下，二叉树的存储单元为节点`TreeNode`，节点之间通过**指针**相连。
- 除了用链表表示，任何类型的二叉树都能用**数组**表示，通过**层序遍历**，可以将链表二叉树转换成数组二叉树。
## 完美二叉树：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/35940756/1721917363559-b6bb8383-7cdd-48f8-b1ed-0449043eb1e9.png#averageHue=%23fbfbfb&clientId=u54edc58c-efd7-4&from=paste&height=413&id=u3560d00d&originHeight=413&originWidth=744&originalType=binary&ratio=1&rotation=0&showTitle=false&size=70847&status=done&style=none&taskId=ud53c28b9-4b99-4dbb-a9d5-273bf93adae&title=&width=744)

- 通过层序遍历，很容易的将完美二叉树的节点存储到数组中，通过**节点的映射关系**计算索引，访问数组元素。
   - 计算得到的数组索引要进行越界检测，非法的索引表示节点不存在。
```java
class BinaryTreeArray{
    public List<TreeNode> toArray(TreeNode root){
        List<TreeNode> treeArray = new ArrayList<>();
        if (root == null){
            return treeArray;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()){
            TreeNode node = queue.poll();
            treeArray.add(node);
            if (node.left != null){
                queue.offer(node.left);
            }
            if (node.right != null){
                queue.offer(node.right);
            }
        }
        return treeArray;
    }
}
```
## 完全二叉树：

- 虽然完全二叉树并不完整，但**None**只会出现在**最底层且靠右**的位置，将完全二叉树补全后再进行转换，**None**也全都出现在**层序遍历的末尾**，这样并不影响二叉树到数组的转换，可以直接使用完美二叉树的代码。

![image.png](https://cdn.nlark.com/yuque/0/2024/png/35940756/1721919769509-9c0fb701-84c9-4ee9-8cbb-769c38eb6e8f.png#averageHue=%23fbfbfb&clientId=u54edc58c-efd7-4&from=paste&height=360&id=u6c9443d0&originHeight=360&originWidth=744&originalType=binary&ratio=1&rotation=0&showTitle=false&size=53896&status=done&style=none&taskId=u7fa56000-9c37-4079-8897-ae1ebbb80e3&title=&width=744)
## 普通二叉树：

- 我们可以**把普通二叉树补全成完美二叉树**，即在遍历的过程中**显式**的写出所有的**None**。

![image.png](https://cdn.nlark.com/yuque/0/2024/png/35940756/1721918811846-8a41954e-2f5b-4652-b801-dc35badcc30f.png#averageHue=%23fcfcfc&clientId=u54edc58c-efd7-4&from=paste&height=418&id=u30ab7000&originHeight=418&originWidth=747&originalType=binary&ratio=1&rotation=0&showTitle=false&size=56466&status=done&style=none&taskId=u567e2e69-65ff-47d5-9a57-1223785ded3&title=&width=747)

- 当把普通二叉树补成完美的叉树的时候，二叉树的每一层都有非None节点。
- 可以记录当前遍历的层次，如果当前层的队列中存在非None节点，说明没有遍历完毕；如果当前层的队列中全是None节点，则遍历完毕。
```java
class BinaryTreeArray{
    public List<TreeNode> toArray(TreeNode root){
        List<TreeNode> treeArray = new ArrayList<>();
        if (root == null){
            return treeArray;
        }
        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (true){
            if (allNull(queue)){
                break;
                //如果当前层的队列全部是null，说明遍历完成
            }
            int currentLevelSize = queue.size();
            for (int i = 0; i < currentLevelSize; i++){
                TreeNode node = queue.poll();
                treeArray.add(node);
                if (node == null){
                    queue.offer(null);
                    queue.offer(null);
                }
                else {
                    queue.offer(node.left);
                    queue.offer(node.right);
                }
            }
        }
        return treeArray;
    }
    private booelan allNull(LinkedList<TreeNode> queue){
        for (int i = 0; i < queue.size(); i++){
            if (queue.get(i) != null){
                return false;
            }
        }
        return true;
    }
}
```

- 上述算法的**时间复杂度**是O(n2)，**空间复杂度**是O(n)，时间复杂度较高，有待改善......
# 二叉搜索树：
## 二叉搜索树的概念：

- 对于**任意节点**，其左子树中所有节点的值 < 当前节点的值 < 右子树中所有节点的值，这样的二叉树叫做**二叉搜索树**。

![image.png](https://cdn.nlark.com/yuque/0/2024/png/35940756/1721922871925-1d28e71d-46d2-433c-8070-1b90343cf241.png#averageHue=%23fefefe&clientId=u54edc58c-efd7-4&from=paste&height=386&id=u182d63ad&originHeight=386&originWidth=723&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36068&status=done&style=none&taskId=ufde911df-c58a-446b-b384-4b5549d9c59&title=&width=723)

- **PS**：二叉搜索树不是完美二叉树，这里是为了美观。
